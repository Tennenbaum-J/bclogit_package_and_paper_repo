# modle_tracking_value <- NA
# pval_modle_tracking_value <- NA
# if (TRUE) {
#   model <- summary(glm(y ~ w + X, family = "binomial"))$coefficients[2, c(1, 2)]
#   beta_hat_T <- model[1]
#   ssq_beta_hat_T <- model[2]
#   pval <- 2 * pnorm(min(c(-1, 1) * (beta_hat_T / ssq_beta_hat_T)))
# }
# res <- rbind(res, data.frame(
#   n = n,
#   p = p,
#   beta_T = beta_T,
#   X_style = X_style,
#   true_funtion = true_funtion,
#   regress_on_X = regress_on_X,
#   inference = "GLM",
#   beta_hat_T = beta_hat_T,
#   ssq_beta_hat_T = ssq_beta_hat_T,
#   pval = pval#,
#   #modle_tracking_value = modle_tracking_value,
#   #pval_modle_tracking_value = pval_modle_tracking_value,
#   #g = NA
# ))
########################### BAYESIAN ###########################
for (prior_type in c("G prior", "Hybrid")) { #"normal", "G prior", "PMP", "Hybrid"
for (concordant_fit in c("GLM", "GEE", "GLMM")) {
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
modle_tracking_value <- NA
pval_modle_tracking_value <- NA
g <- NA
if (discordant_viabele & concordant_viabele) {
model <- Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, prior_type, concordant_fit)
beta_hat_T <- model$betaT
ssq_beta_hat_T <- model$ssq_beta_T
pval <- model$pval
g = model$g
}
res <- rbind(res, data.frame(
n = n,
p = p,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = paste0("bayesian_", prior_type, "_", concordant_fit),
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval,
#modle_tracking_value = modle_tracking_value,
#pval_modle_tracking_value = pval_modle_tracking_value,
g = g
))
}
}
########################### glmmTMB  ###########################
# beta_hat_T <- NA
# ssq_beta_hat_T <- NA
# pval <- NA
# modle_tracking_value <- NA
# pval_modle_tracking_value <- NA
# tryCatch(
#   {
#     fit_tmb <- glmmTMB(
#       y ~ X + w + (1 | strat),
#       family = binomial(),
#       data   = data.frame(y, X, w, strat)
#     )
#     model <- summary(fit_tmb)$coefficients$cond["w", c("Estimate", "Std. Error")]
#     beta_hat_T <- model[1]
#     ssq_beta_hat_T <- model[2]
#     pval <- 2 * pnorm(min(c(-1, 1) * (beta_hat_T / ssq_beta_hat_T)))
#     modle_tracking_value = VarCorr(fit_tmb)$cond$strat[1,1]
#
#     m_null <- glmmTMB(
#       y ~ X + w,
#       family = binomial(),
#       data   = data.frame(y, X, w, strat)
#     )
#     pval_modle_tracking_value <- anova(m_null, fit_tmb)[2, "Pr(>Chisq)"]
#
#   },
#   error = function(e) {
#     beta_hat_T <<- NA
#     ssq_beta_hat_T <<- NA
#     pval <<- NA
#   }
# )
# res <- rbind(res, data.frame(
#   n = n,
#   p = p,
#   beta_T = beta_T,
#   X_style = X_style,
#   true_funtion = true_funtion,
#   regress_on_X = regress_on_X,
#   inference = "GLMM",
#   beta_hat_T = beta_hat_T,
#   ssq_beta_hat_T = ssq_beta_hat_T,
#   pval = pval#,
#   #modle_tracking_value = modle_tracking_value,
#   #pval_modle_tracking_value = pval_modle_tracking_value,
#   #g = NA
# ))
########################### GEE  ###########################
# beta_hat_T <- NA
# ssq_beta_hat_T <- NA
# pval <- NA
# modle_tracking_value <- NA
# pval_modle_tracking_value <- NA
# tryCatch(
#   {
#     fit_gee <- geeglm(
#       y ~ X + w,
#       id = strat,
#       family = binomial(link = "logit"),
#       corstr = "exchangeable",
#       data = data.frame(y, X, w, strat)
#     )
#     model <- summary(fit_gee)$coefficients["w", c("Estimate", "Std.err")]
#     beta_hat_T <- as.numeric(model[1])
#     ssq_beta_hat_T <- as.numeric(model[2])
#     pval <- 2 * pnorm(min(c(-1, 1) * (beta_hat_T / ssq_beta_hat_T)))
#     modle_tracking_value <- as.numeric(summary(fit_gee)$corr["Estimate"])
#     pval_modle_tracking_value <- 2 * pnorm(as.numeric(abs(modle_tracking_value / summary(fit_gee)$corr["Std.err"])), lower.tail = FALSE)
#
#   },
#   error = function(e) {
#     beta_hat_T <<- NA
#     ssq_beta_hat_T <<- NA
#     pval <<- NA
#   }
# )
# res <- rbind(res, data.frame(
#   n = n,
#   p = p,
#   beta_T = beta_T,
#   X_style = X_style,
#   true_funtion = true_funtion,
#   regress_on_X = regress_on_X,
#   inference = "GEE",
#   beta_hat_T = beta_hat_T,
#   ssq_beta_hat_T = ssq_beta_hat_T,
#   pval = pval#,
#   #modle_tracking_value = modle_tracking_value,
#   #pval_modle_tracking_value = pval_modle_tracking_value,
#   #g = NA
# ))
########################### STAN_GLMER ###########################
# beta_hat_T <- NA
# ssq_beta_hat_T <- NA
# pval <- NA
# tryCatch(
#   {
#     fit_stan <- stan_glmer(
#       y ~ X + w + (1 | strat),
#       family = binomial(link = "logit"),
#       data = data.frame(y, X, w, strat),
#       prior = normal(0, 2.5),
#       prior_intercept = normal(0, 5),
#       chains = 2,
#       iter = 2000,
#       refresh = 0
#     )
#
#     post <- as.matrix(fit_stan)
#     w_draws <- post[, "w"]
#
#     beta_hat_T <- mean(w_draws)
#     ssq_beta_hat_T <- sd(w_draws)
#
#     reject <- !(quantile(w_draws, 0.025) < 0 & quantile(w_draws, 0.975) > 0)
#     pval <- if (reject) 0 else 1
#   },
#   error = function(e) {
#     beta_hat_T <<- NA
#     ssq_beta_hat_T <<- NA
#     pval <<- NA
#   }
# )
# res <- rbind(res, data.frame(
#   n = n,
#   p = p,
#   beta_T = beta_T,
#   X_style = X_style,
#   true_funtion = true_funtion,
#   regress_on_X = regress_on_X,
#   inference = "stan_glmer",
#   beta_hat_T = beta_hat_T,
#   ssq_beta_hat_T = ssq_beta_hat_T,
#   pval = pval
# ))
########################### binaryMM ###########################
# beta_hat_T = NA; ssq_beta_hat_T = NA; pval = NA
# tryCatch({
#   # binaryMM requires a data frame and explicit column names
#   df_mm = data.frame(y = y, w = w, strat = strat)
#   df_mm = cbind(df_mm, X) # Add covariates
#
#   # Construct the formula dynamically based on X columns
#   if (is.null(colnames(X))) {
#     colnames(X) = paste0("V", 1:ncol(X))
#   }
#   x_names = colnames(X)
#   mm_formula = as.formula(paste("y ~ w +", paste(x_names, collapse = " + ")))
#
#   fit_mm = mm(
#     formula = mm_formula,
#     id = strat,
#     data = df_mm,
#     # 'average' provides the population-averaged (marginal) effects
#     # similar to GEE, but via a different estimation method
#     type = "marginal"
#   )
#
#   # Extracting coefficients for the treatment effect 'w'
#   # binaryMM stores results in a 'coefficients' matrix
#   mm_sum = summary(fit_mm)
#   beta_hat_T = mm_sum$coefficients["w", "Estimate"]
#   ssq_beta_hat_T = mm_sum$coefficients["w", "Std.Error"]
#
#   # Standard Wald-type p-value calculation
#   pval = 2 * pnorm(-abs(beta_hat_T / ssq_beta_hat_T))
#
# }, error = function(e) {
#   beta_hat_T <<- NA; ssq_beta_hat_T <<- NA; pval <<- NA
# })
#
# res = rbind(res, data.frame(
#   n = n,
#   p = p,
#   beta_T = beta_T,
#   X_style = X_style,
#   true_funtion = true_funtion,
#   regress_on_X = regress_on_X,
#   inference = "binaryMM",
#   beta_hat_T = beta_hat_T,
#   ssq_beta_hat_T = ssq_beta_hat_T,
#   pval = pval
# ))
} else { # if no x then remove the x parameter
discordant_viabele <- if (length(y_dis) > 5) {
TRUE
} else {
FALSE
}
########################### CLOGIT  ###########################
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
if (discordant_viabele) {
y_dis_0_1 <- ifelse(y_dis == -1, 0, 1)
model <- summary(glm(y_dis_0_1 ~ 0 + w_dis, family = "binomial"))$coefficients[1, c(1, 2)]
beta_hat_T <- model[1]
ssq_beta_hat_T <- model[2]
pval <- 2 * pnorm(min(c(-1, 1) * (beta_hat_T / ssq_beta_hat_T)))
}
res <- rbind(res, data.frame(
n = n,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "clogit",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
########################### LOGIT  ###########################
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
if (discordant_viabele) {
model <- summary(glm(y ~ w, family = "binomial"))$coefficients[2, c(1, 2)]
beta_hat_T <- model[1]
ssq_beta_hat_T <- model[2]
pval <- 2 * pnorm(min(c(-1, 1) * (beta_hat_T / ssq_beta_hat_T)))
}
res <- rbind(res, data.frame(
n = n,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "logit",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
########################### glmmTMB  ###########################
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
tryCatch(
{
fit_tmb <- glmmTMB(
y ~ w + (1 | strat),
family = binomial(),
data   = data.frame(y, X, w, strat)
)
model <- summary(fit_tmb)$coefficients$cond["w", c("Estimate", "Std. Error")]
beta_hat_T <- model[1]
ssq_beta_hat_T <- model[2]
pval <- 2 * pnorm(min(c(-1, 1) * (beta_hat_T / ssq_beta_hat_T)))
},
error = function(e) {
beta_hat_T <<- NA
ssq_beta_hat_T <<- NA
pval <<- NA
}
)
res <- rbind(res, data.frame(
n = n,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "glmmTMB",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
########################### GEE  ###########################
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
tryCatch(
{
fit_gee <- geeglm(
y ~ w,
id = strat,
family = binomial(link = "logit"),
corstr = "exchangeable",
data = data.frame(y, X, w, strat)
)
model <- summary(fit_gee)$coefficients["w", c("Estimate", "Std.err")]
beta_hat_T <- as.numeric(model[1])
ssq_beta_hat_T <- as.numeric(model[2])
pval <- 2 * pnorm(min(c(-1, 1) * (beta_hat_T / ssq_beta_hat_T)))
},
error = function(e) {
beta_hat_T <<- NA
ssq_beta_hat_T <<- NA
pval <<- NA
}
)
res <- rbind(res, data.frame(
n = n,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "GEE",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
}
rownames(res) <- NULL
return(res)
}
Run_sim <- function(p, beta_T, n, X_style) {
BIG_res <- data.frame()
y <- array(NA, n)
probs <- array(NA, n)
if (X_style == "correlated") { ############## correlated is the old style
Sigma <- 1 * (matrix(0.5, nrow = p, ncol = p) + diag(1 - 0.5, p))
X <- MASS::mvrnorm(n / 2, rep(0, p), Sigma)
X <- pnorm(X)
X <- matrix(2 * X - 1, ncol = p)
} else {
X <- matrix(runif((n / 2) * p, min = -1, max = 1), ncol = p)
X_plus_eps <- X + matrix(rnorm((n / 2) * p, 0, 0.05), ncol = p)
combined <- rbind(X, X_plus_eps)
ids <- order(c(1:(n / 2), 1:(n / 2)))
X <- combined[ids, ]
X[, 1] <- runif(n, min = -1, max = 1)
rm(X_plus_eps, combined, ids)
}
w <- c(rbind(replicate(n / 2, sample(c(0, 1)), simplify = TRUE)))
strat <- rep(1:(n / 2), each = 2)
for (true_funtion in true_funtions) {
if (true_funtion == "linear") {
beta_X_value <- if (p == 6) {
1.25
} else {
0.75
}
beta_X <- rep(beta_X_value, p)
beta_0 <- -0.5
probs <- 1 / (1 + exp(-(beta_0 + (as.matrix(X) %*% beta_X) + beta_T * w)))
} else {
f_x <- sin(pi * X[, 1] * X[, 2]) + X[, 3]^3 + X[, 4]^2 + X[, 5]^2
probs <- 1 / (1 + exp(-(f_x + beta_T * w)))
}
y <- rbinom(n, 1, probs)
# df = data.frame(y = y, probs = probs)
# ggplot(df, aes(x = probs, fill = factor(y))) +
#   geom_histogram(position = "identity", alpha = 0.6, bins = 30) +
#   labs(x = "Predicted probability", fill = "Outcome") +
#   scale_fill_manual(values = c("0" = "red", "1" = "blue")) +
#   theme_minimal()
for (regress_on_X in regress_on_Xs) {
if (regress_on_X == "one") {
X_run <- X[, 1, drop = FALSE]
} else if (regress_on_X == "some") {
if (p == 20) {
X_run <- X[, 1:5, drop = FALSE]
} else {
X_run <- X[, c(1, 2), drop = FALSE]
}
} else {
X_run <- X
}
one_res <- Do_Inference(y, X_run, w, strat, p, beta_T, n, X_style, true_funtion, regress_on_X)
BIG_res <- rbind(BIG_res, one_res)
}
}
return(BIG_res)
}
handlers(global = TRUE)
handlers("txtprogressbar")
registerDoFuture()
plan(multisession, workers = num_cores)
plan(sequential)
num_cores <- availableCores() - 4
handlers(global = TRUE)
handlers("txtprogressbar")
registerDoFuture()
plan(multisession, workers = num_cores)
for (e_nsim in 1:external_nsim) {
with_progress({
prog <- progressor(along = 1:nrow(params))
results <- foreach(
row = iter(params, by = "row"),
.combine = rbind,
.packages = c(
"bclogit", "nbpMatching", "data.table",
"dplyr", "MASS", "Rcpp", "rstanarm"
)
) %dorng% {
# extract parameters
nsim <- row$nsim
p <- row$p
beta_T <- row$beta_T
n <- row$n
X_style <- row$X_style
res <- tryCatch(
{
out <- Run_sim(p, beta_T, n, X_style)
# cat("Successfully ran simulation")
prog()
out
},
error = function(e) {
cat(glue::glue("Error in nsim={nsim}: {e$message}"), "\n")
prog() # still update progress bar even if it fails
NULL # return NULL if failed, will be dropped in rbind
}
)
}
})
write.csv(results, file = paste0("C:/temp/clogitR_kap_test_from_scratch/", Nsim, "_", e_nsim, "_g_prior.csv"), row.names = FALSE)
rm(results)
gc()
}
results <- read.csv("C:/temp/clogitR_kap_test_from_scratch/100_1_g_prior.csv")
sum <- 1
for (i in 2:100) {
file_path <- paste0("C:/temp/clogitR_kap_test_from_scratch/100_", i, "_g_prior.csv")
if (file.exists(file_path)) {
sum <- sum + 1
message("Reading file ", i)
temp <- read.csv(file_path)
results <- rbind(results, temp)
} else {
message("Skipping missing file ", i)
}
}
results$X <- NULL
res_mod <- results %>%
mutate(
lower_ci = beta_hat_T - (1.96 * ssq_beta_hat_T),
upper_ci = beta_hat_T + (1.96 * ssq_beta_hat_T),
covered = (lower_ci <= beta_T) & (upper_ci >= beta_T),
sq_err = (beta_hat_T - beta_T)^2,
rej = pval < 0.05,
#rej_mtv = pval_modle_tracking_value < 0.05
) %>%
group_by(p, beta_T, true_funtion, regress_on_X, n, inference, X_style) %>%
summarize(
num_na = sum(is.na(pval)),
num_real = sum(!is.na(pval)),
mse = mean(sq_err, na.rm = TRUE, trim = 0.001),
med_mse = median(sq_err, na.rm = TRUE),
percent_reject = sum(rej, na.rm = TRUE) / (n() - num_na),
coverage = mean(covered, na.rm = TRUE),
mean_beta_hat_T = mean(beta_hat_T, na.rm = TRUE),
mean_sq_beta_hat_T = mean(ssq_beta_hat_T, trim = 0.001, na.rm = TRUE),
significant = binom.test(sum(rej, na.rm = TRUE), n = (n() - num_na),  p = 0.05)$p.value,
coverage_sig = binom.test(x = sum(covered, na.rm = TRUE), n = sum(!is.na(covered)), p = 0.95)$p.value,
#mean_mtv = mean(modle_tracking_value, trim = 0.001, na.rm = TRUE),
#num_na_mtv = sum(is.na(pval_modle_tracking_value)),
#percent_reject_mtv = sum(rej_mtv, na.rm = TRUE) / (n() - num_na_mtv),
#significant_mtv = ifelse(num_na_mtv < 0.9 * n(), binom.test(sum(rej_mtv, na.rm = TRUE), n = (n() - num_na_mtv),  p = 0.05)$p.value, NaN),
mean_g = mean(g, na.rm = TRUE),
.groups = "drop"
)
write.csv(res_mod, file = "C:/temp/clogitR_kap_test_from_scratch/combined_10000_3_g_prior.csv", row.names = FALSE)
