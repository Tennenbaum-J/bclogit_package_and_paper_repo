q()
ls("package:glmmTMB")
library(glmmTMB)
ls("package:glmmTMB")
ls("package:bclogit")
library(bclogit)
ls("package:bclogit")
lsf.str("package:bclogit")
getNamespaceExports("bclogit")
ls(getNamespace(bclogt), all.names = TRUE)
ls(getNamespace("bclogt"), all.names = TRUE)
ls(getNamespace("bclogit"), all.names = TRUE)
ls(getNamespace("glmTMB"), all.names = TRUE)
ls(getNamespace("glmmTMB"), all.names = TRUE)
library(riskCommunicator)
data("framingham")
D=data.table(framingham)
pacman::p_load(dplyr, tidyr, data.table, doFuture, future, doRNG, foreach, progressr, doParallel, nbpMatching, doParallel, ggplot2, geepack, glmmTMB, rstan, binaryMM, rstanarm) # doParallel
if (!require("bclogit", character.only = TRUE)) {
remotes::install_local("bclogit", dependencies = FALSE, force = TRUE, upgrade = "never")
library(bclogit)
}
# Priors
sm <- rstan::stan_model("mvn_logistic.stan")                #naive
sm_g <- rstan::stan_model("mvn_logistic_gprior.stan")       #g prior
sm_PMP <- rstan::stan_model("mvn_logistic_PMP.stan")        #PMP
sm_hybrid <- rstan::stan_model("mvn_logistic_Hybrid.stan")  #Hybrid
setwd("C:/Users/Jacob/clogitR_package_and_paper_repo/package_tests")
# Priors
sm <- rstan::stan_model("mvn_logistic.stan")                #naive
sm_g <- rstan::stan_model("mvn_logistic_gprior.stan")       #g prior
sm_PMP <- rstan::stan_model("mvn_logistic_PMP.stan")        #PMP
sm_hybrid <- rstan::stan_model("mvn_logistic_Hybrid.stan")  #Hybrid
data("framingham")
D=data.table(framingham)
D=D[!is.na(CIGPDAY)]
D=D[!is.na(BMI)]
D=D[!is.na(HEARTRTE)]
D=D[!is.na(TOTCHOL)]
D=D[!is.na(SYSBP)]
D=D[!is.na(DIABP)]
D=D[!is.na(CURSMOKE)]
D=D[!is.na(DIABETES)]
D=D[!is.na(BPMEDS)]
Dba = D[PERIOD %in% c(1,3)]
Dba[, num_periods_per_id := .N, by = RANDID]
Dba = Dba[num_periods_per_id == 2]
Dba[, num_periods_per_id := NULL]
rm(framingham, D)
strat = current_data$RANDID
strat = Dba$RANDID
w = ifelse(Dba$PERIOD == 1, 1, 0)
y = Dba$PREVCHD
X = Dba[, c("TOTCHOL", "SYSBP", "DIABP", "CURSMOKE", "CIGPDAY", "BMI", "DIABETES", "BPMEDS", "HEARTRTE")]
res <- data.frame(
inference = character(),
beta_hat_T = numeric(),
pval = numeric()
)
matched_data <-
bclogit:::process_matched_pairs_cpp(
strata = strat,
y = y,
X = data.matrix(X),
treatment = w
)
X_con <- matched_data$X_concordant
y_con <- matched_data$y_concordant
w_con <- matched_data$treatment_concordant
X_dis <- matched_data$X_diffs_discordant
y_dis <- matched_data$y_diffs_discordant
w_dis <- matched_data$treatment_diffs_discordant
dis_idx <- matched_data$discordant_idx + 1
strat_con = strat[setdiff(1:n, dis_idx)]
dis_idx
dis_idx
strat_con
strat_con = strat[setdiff(1:n, which(strat %in% dis_idx))]
dis_idx
which(strat %in% dis_idx)
strat %in% dis_idx
strat
setdiff(1:n, dis_idx)
1:n
strat_con = strat[setdiff(1:length(strat), dis_idx)]
strat_con
# CLOGIT  #
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
y_dis_0_1 <- ifelse(y_dis == -1, 0, 1)
model <- summary(glm(y_dis_0_1 ~ 0 + w_dis + X_dis, family = "binomial"))$coefficients[1, c(1, 2)]
beta_hat_T <- model[1]
ssq_beta_hat_T <- model[2]
pval <- 2 * pnorm(min(c(-1, 1) * (beta_hat_T / ssq_beta_hat_T)))
res <- rbind(res, data.frame(
inference = "clogit",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
res
w = ifelse(Dba$PERIOD == 3, 1, 0)
res <- data.frame(
inference = character(),
beta_hat_T = numeric(),
pval = numeric()
)
matched_data <-
bclogit:::process_matched_pairs_cpp(
strata = strat,
y = y,
X = data.matrix(X),
treatment = w
)
X_con <- matched_data$X_concordant
y_con <- matched_data$y_concordant
w_con <- matched_data$treatment_concordant
X_dis <- matched_data$X_diffs_discordant
y_dis <- matched_data$y_diffs_discordant
w_dis <- matched_data$treatment_diffs_discordant
dis_idx <- matched_data$discordant_idx + 1
strat_con = strat[setdiff(1:length(strat), dis_idx)]
# CLOGIT  #
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
y_dis_0_1 <- ifelse(y_dis == -1, 0, 1)
model <- summary(glm(y_dis_0_1 ~ 0 + w_dis + X_dis, family = "binomial"))$coefficients[1, c(1, 2)]
beta_hat_T <- model[1]
ssq_beta_hat_T <- model[2]
pval <- 2 * pnorm(min(c(-1, 1) * (beta_hat_T / ssq_beta_hat_T)))
res <- rbind(res, data.frame(
inference = "clogit",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
# BAYESIAN  #
for (prior_type in c("naive", "G prior", "PMP", "Hybrid")) {
for (concordant_fit in c("GLM", "GEE", "GLMM")) {
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
if (discordant_viabele & concordant_viabele) {
model <- Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, prior_type, concordant_fit)
beta_hat_T <- model$betaT
ssq_beta_hat_T <- model$ssq_beta_T
pval <- model$pval
g = model$g
}
res <- rbind(res, data.frame(
inference = paste0("bayesian_", prior_type, "_", concordant_fit),
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
}
}
# BAYESIAN  #
for (prior_type in c("naive", "G prior", "PMP", "Hybrid")) {
for (concordant_fit in c("GLM", "GEE", "GLMM")) {
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
model <- Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, prior_type, concordant_fit)
beta_hat_T <- model$betaT
ssq_beta_hat_T <- model$ssq_beta_T
pval <- model$pval
g = model$g
res <- rbind(res, data.frame(
inference = paste0("bayesian_", prior_type, "_", concordant_fit),
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
}
}
res
# Runs bclogit without the package. This is how it works at the time of simulation for the paper
# called from `Do_Inference`
Bayesian_Clogit <- function(y_dis, X_dis, w_dis, y_con, X_con, w_con, prior_type, concordant_fit) {
# NOTE ON THE CONCORDANT MODLES:
# Since we include `w` in the concordant regression we have to get rid of a column from the estimate to match the dimension of the discordant model.
# Additionaly we assume a flat prior for the treatment effect, hence setting it to mean 0 and high var.
if (concordant_fit == "GLM") {
fit_con <- glm(y_con ~ w_con + X_con, family = "binomial")
b_con <- summary(fit_con)$coefficients[, 1]
Sigma_con <- pmin(vcov(fit_con), 1e3)
eps <- 1e-6 # added for stabilibty
Sigma_con <- Sigma_con + diag(eps, nrow(Sigma_con))
b_con <- c(0, b_con[-c(1,2)])
Sigma_con <- Sigma_con[-1, -1]
Sigma_con[1, ] <- 0
Sigma_con[, 1] <- 0
Sigma_con[1, 1] <- 1e3
}
if (concordant_fit == "GEE") {
strat_con <- rep(1:(nrow(X_con) / 2), each = 2)
fit_con <- geeglm(
y_con ~ w_con + X_con,
id = strat_con,
family = binomial(link = "logit"),
corstr = "exchangeable",
data = data.frame(y_con, w_con, X_con, strat_con)
)
b_con <- summary(fit_con)$coefficients[, 1]
Sigma_con <- pmin(vcov(fit_con), 1e3)
eps <- 1e-6 # added for stabilibty
Sigma_con <- Sigma_con + diag(eps, nrow(Sigma_con))
b_con <- c(0, b_con[-c(1,2)])
Sigma_con <- Sigma_con[-1, -1]
Sigma_con[1, ] <- 0
Sigma_con[, 1] <- 0
Sigma_con[1, 1] <- 1e3
}
if (concordant_fit == "GLMM") {
strat_con <- rep(1:(nrow(X_con) / 2), each = 2)
fit_con <- glmmTMB(
y_con ~  w_con + X_con + (1 | strat_con),
family = binomial(),
data   = data.frame(y_con, w_con, X_con, strat_con)
)
b_con <- summary(fit_con)$coefficients$cond[, 1]
Sigma_con <- pmin(vcov(fit_con)$cond, 1e3)
eps <- 1e-6 # added for stabilibty
Sigma_con <- Sigma_con + diag(eps, nrow(Sigma_con))
b_con <- c(0, b_con[-c(1,2)])
Sigma_con <- Sigma_con[-1, -1]
Sigma_con[1, ] <- 0
Sigma_con[, 1] <- 0
Sigma_con[1, 1] <- 1e3
}
# conditional logistic regression is the same as logistic regression as long as the response is set to be 0 or 1.
y_dis_0_1 <- ifelse(y_dis == -1, 0, 1)
wX_dis <- cbind(w_dis, X_dis)
g = NA
if (prior_type == "naive") {
if (all(diag(Sigma_con) == 1e3 + eps)) {
ret <- list()
ret$betaT <- NA
ret$ssq_beta_T <- NA
ret$reject <- NA
ret$pval <- NA
return(ret) # model blew up
}
data_list <- list(
N = nrow(wX_dis),
K = ncol(wX_dis),
X = wX_dis,
y = y_dis_0_1,
mu = b_con,
Sigma = Sigma_con
)
discordant_model <- tryCatch(
{
summary(rstan::sampling(sm, data = data_list, refresh = 0, chains = 1))$summary["beta[1]", c("mean", "sd", "2.5%", "97.5%")]
},
error = function(e) {
warning(sprintf("stan_glm failed: %s", e$message))
NULL
}
)
}
if (prior_type == "G prior") {
if (all(diag(Sigma_con) == 1e3)) {
ret <- list()
ret$betaT <- NA
ret$ssq_beta_T <- NA
ret$reject <- NA
ret$pval <- NA
return(ret) # model blew up
}
data_list <- list(
N = nrow(wX_dis),
K = ncol(wX_dis),
X = wX_dis,
y = y_dis_0_1,
mu = b_con,
Sigma = Sigma_con
)
discordant_model <- tryCatch(
{
mod = summary(rstan::sampling(sm_g, data = data_list, refresh = 0, chains = 1))$summary
g = mod["g", "mean"]
mod["beta[1]", c("mean", "sd", "2.5%", "97.5%")]
},
error = function(e) {
warning(sprintf("stan_glm failed: %s", e$message))
NULL
}
)
}
if (prior_type == "PMP") {
proj_matrix <- X_dis %*% solve(t(X_dis) %*% X_dis) %*% t(X_dis)
w_dis_ortho <- w_dis - proj_matrix %*% w_dis
data_list <- list(
N = nrow(X_dis),
P = ncol(X_dis),
y = y_dis_0_1,
xw = as.vector(w_dis_ortho),
X = X_dis,
mu_A = as.array(b_con[-1]),
Sigma_A = as.matrix(Sigma_con[-1, -1, drop = FALSE])
)
discordant_model <- tryCatch(
{
summary(rstan::sampling(sm_PMP, data = data_list, refresh = 0, chains = 1))$summary["beta_w", c("mean", "sd", "2.5%", "97.5%")]
},
error = function(e) {
warning(sprintf("stan_glm failed: %s", e$message))
NULL
}
)
}
if (prior_type == "Hybrid") {
proj_matrix <- X_dis %*% solve(t(X_dis) %*% X_dis) %*% t(X_dis)
w_dis_ortho <- w_dis - proj_matrix %*% w_dis
data_list <- list(
N = nrow(X_dis),
P = ncol(X_dis),
y = y_dis_0_1,
xw = as.vector(w_dis_ortho),
X = X_dis,
mu_A = as.array(b_con[-1]),
Sigma_A = as.matrix(Sigma_con[-1, -1, drop = FALSE])
)
discordant_model <- tryCatch(
{
mod = summary(rstan::sampling(sm_hybrid, data = data_list, refresh = 0, chains = 1))$summary
g = mod["g", "mean"]
mod["beta_w", c("mean", "sd", "2.5%", "97.5%")]
},
error = function(e) {
warning(sprintf("Hybrid PMP failed: %s", e$message))
NULL
}
)
}
ret <- list(
betaT = NA,
ssq_beta_T = NA,
reject = NA,
pval = NA,
g = NA
)
if (!is.null(discordant_model)) {
ret$betaT <- discordant_model[1]
ret$ssq_beta_T <- discordant_model[2]
ret$reject <- !(discordant_model[3] < 0 & discordant_model[4] > 0)
ret$pval <- if (ret$reject) 0 else 1
}
if (!is.null(g)) { ret$g = g }
return(ret)
}
# BAYESIAN  #
for (prior_type in c("naive", "G prior", "PMP", "Hybrid")) {
for (concordant_fit in c("GLM", "GEE", "GLMM")) {
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
model <- Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, prior_type, concordant_fit)
beta_hat_T <- model$betaT
ssq_beta_hat_T <- model$ssq_beta_T
pval <- model$pval
g = model$g
res <- rbind(res, data.frame(
inference = paste0("bayesian_", prior_type, "_", concordant_fit),
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
}
}
res
round(res, 4)
library(dplyr)
res_rounded <- res %>%
mutate(across(where(is.numeric), \(x) round(x, 4)))
res_rounded
prior_type = "naive"
concordant_fit = "GLM"
model <- Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, prior_type, concordant_fit)
beta_hat_T <- model$betaT
ssq_beta_hat_T <- model$ssq_beta_T
pval <- model$pval
beta_hat_T ; ssq_beta_hat_T ; pval
model <- Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, prior_type, concordant_fit)
beta_hat_T <- model$betaT
ssq_beta_hat_T <- model$ssq_beta_T
pval <- model$pval
beta_hat_T ; ssq_beta_hat_T ; pval
model <- Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, prior_type, concordant_fit)
beta_hat_T <- model$betaT
ssq_beta_hat_T <- model$ssq_beta_T
pval <- model$pval
beta_hat_T ; ssq_beta_hat_T ; pval
model <- Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, prior_type, concordant_fit)
beta_hat_T <- model$betaT
ssq_beta_hat_T <- model$ssq_beta_T
pval <- model$pval
beta_hat_T ; ssq_beta_hat_T ; pval
model <- Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, prior_type, concordant_fit)
beta_hat_T <- model$betaT
ssq_beta_hat_T <- model$ssq_beta_T
pval <- model$pval
beta_hat_T ; ssq_beta_hat_T ; pval
model <- Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, prior_type, concordant_fit)
beta_hat_T <- model$betaT
ssq_beta_hat_T <- model$ssq_beta_T
pval <- model$pval
beta_hat_T ; ssq_beta_hat_T ; pval
model <- Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, prior_type, concordant_fit)
beta_hat_T <- model$betaT
ssq_beta_hat_T <- model$ssq_beta_T
pval <- model$pval
beta_hat_T ; ssq_beta_hat_T ; pval
model <- Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, prior_type, concordant_fit)
beta_hat_T <- model$betaT
ssq_beta_hat_T <- model$ssq_beta_T
pval <- model$pval
beta_hat_T ; ssq_beta_hat_T ; pval
model <- Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, prior_type, concordant_fit)
beta_hat_T <- model$betaT
ssq_beta_hat_T <- model$ssq_beta_T
pval <- model$pval
beta_hat_T ; ssq_beta_hat_T ; pval
model <- Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, prior_type, concordant_fit)
beta_hat_T <- model$betaT
ssq_beta_hat_T <- model$ssq_beta_T
pval <- model$pval
beta_hat_T ; ssq_beta_hat_T ; pval
model <- Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, prior_type, concordant_fit)
beta_hat_T <- model$betaT
ssq_beta_hat_T <- model$ssq_beta_T
pval <- model$pval
beta_hat_T ; ssq_beta_hat_T ; pval
model <- Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, prior_type, concordant_fit)
beta_hat_T <- model$betaT
ssq_beta_hat_T <- model$ssq_beta_T
pval <- model$pval
beta_hat_T ; ssq_beta_hat_T ; pval
model <- Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, prior_type, concordant_fit)
beta_hat_T <- model$betaT
ssq_beta_hat_T <- model$ssq_beta_T
pval <- model$pval
beta_hat_T ; ssq_beta_hat_T ; pval
res
res_rounded
# BAYESIAN  #
for (prior_type in c("naive", "G prior", "PMP", "Hybrid")) {
for (concordant_fit in c("GLM", "GEE", "GLMM")) {
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
model <- Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, prior_type, concordant_fit)
beta_hat_T <- model$betaT
ssq_beta_hat_T <- model$ssq_beta_T
pval <- model$pval
beta_hat_T ; ssq_beta_hat_T ; pval
g = model$g
res <- rbind(res, data.frame(
inference = paste0("bayesian_", prior_type, "_", concordant_fit),
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
}
}
res
res <- data.frame(
inference = character(),
beta_hat_T = numeric(),
pval = numeric()
)
y_con + 2*y_dis
length(y_con) + 2*length(y_dis)
