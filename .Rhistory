)
if (!is.null(discordant_model)) {
ret$betaT <- discordant_model[1]
ret$ssq_beta_T <- discordant_model[2]
ret$reject <- !(discordant_model[3] < 0 & discordant_model[4] > 0)
ret$pval <- if (ret$reject) 0 else 1
}
return(ret)
}
Do_Inference <- function(y, X, w, strat, p, beta_T, n, X_style, true_funtion, regress_on_X) {
res <- data.frame(
n = numeric(),
p = numeric(),
beta_T = numeric(),
X_style = character(),
true_funtion = character(),
regress_on_X = character(),
inference = character(),
beta_hat_T = numeric(),
pval = numeric()
)
matched_data <-
process_matched_pairs_cpp(
strata = strat,
y = y,
X = data.matrix(X),
treatment = w
)
X_con <- matched_data$X_concordant
y_con <- matched_data$y_concordant
w_con <- matched_data$treatment_concordant
X_dis <- matched_data$X_diffs_discordant
y_dis <- matched_data$y_diffs_discordant
w_dis <- matched_data$treatment_diffs_discordant
dis_idx <- matched_data$discordant_idx + 1
if (regress_on_X %in% c("one", "some")) { # "all",
discordant_viabele <- if (length(y_dis) > ncol(X) + 7) {
TRUE
} else {
FALSE
}
concordant_viabele <- if (length(y_con) > ncol(X) + 7) {
TRUE
} else {
FALSE
}
########################### CLOGIT  ###########################
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
if (discordant_viabele) {
y_dis_0_1 <- ifelse(y_dis == -1, 0, 1)
model <- summary(glm(y_dis_0_1 ~ 0 + w_dis + X_dis, family = "binomial"))$coefficients[1, c(1, 2)]
beta_hat_T <- model[1]
ssq_beta_hat_T <- model[2]
pval <- 2 * pnorm(min(c(-1, 1) * (beta_hat_T / ssq_beta_hat_T)))
}
res <- rbind(res, data.frame(
n = n,
p = p,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "clogit",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
########################### LOGIT  ###########################
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
if (TRUE) {
model <- summary(glm(y ~ w + X, family = "binomial"))$coefficients[2, c(1, 2)]
beta_hat_T <- model[1]
ssq_beta_hat_T <- model[2]
pval <- 2 * pnorm(min(c(-1, 1) * (beta_hat_T / ssq_beta_hat_T)))
}
res <- rbind(res, data.frame(
n = n,
p = p,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "logit",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
########################### BAYESIAN ###########################
for (prior_type in c("normal", "G prior", "PMP", "Hybrid")) {
for (concordant_fit in c("GLM", "GEE", "GLMM")) {
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
pval_freq <- NA
if (discordant_viabele & concordant_viabele) {
model <- Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, prior_type, concordant_fit)
beta_hat_T <- model$betaT
ssq_beta_hat_T <- model$ssq_beta_T
pval <- model$pval
# pval_freq = 2 * pnorm(min(c(-1,1) * (beta_hat_T / ssq_beta_hat_T)))
}
res <- rbind(res, data.frame(
n = n,
p = p,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = paste0("bayesian_", prior_type, "_", concordant_fit),
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
}
}
########################### glmmTMB  ###########################
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
tryCatch(
{
fit_tmb <- glmmTMB(
y ~ X + w + (1 | strat),
family = binomial(),
data   = data.frame(y, X, w, strat)
)
model <- summary(fit_tmb)$coefficients$cond["w", c("Estimate", "Std. Error")]
beta_hat_T <- model[1]
ssq_beta_hat_T <- model[2]
pval <- 2 * pnorm(min(c(-1, 1) * (beta_hat_T / ssq_beta_hat_T)))
},
error = function(e) {
beta_hat_T <<- NA
ssq_beta_hat_T <<- NA
pval <<- NA
}
)
res <- rbind(res, data.frame(
n = n,
p = p,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "GLMM",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
########################### GEE  ###########################
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
tryCatch(
{
fit_gee <- geeglm(
y ~ X + w,
id = strat,
family = binomial(link = "logit"),
corstr = "exchangeable",
data = data.frame(y, X, w, strat)
)
model <- summary(fit_gee)$coefficients["w", c("Estimate", "Std.err")]
beta_hat_T <- as.numeric(model[1])
ssq_beta_hat_T <- as.numeric(model[2])
pval <- 2 * pnorm(min(c(-1, 1) * (beta_hat_T / ssq_beta_hat_T)))
},
error = function(e) {
beta_hat_T <<- NA
ssq_beta_hat_T <<- NA
pval <<- NA
}
)
res <- rbind(res, data.frame(
n = n,
p = p,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "GEE",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
########################### STAN_GLMER ###########################
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
tryCatch(
{
fit_stan <- stan_glmer(
y ~ X + w + (1 | strat),
family = binomial(link = "logit"),
data   = data.frame(y, X, w, strat),
prior  = normal(0, 2.5),
prior_intercept = normal(0, 5),
chains = 2,
iter   = 2000,
refresh = 0
)
post <- as.matrix(fit_stan)
w_draws <- post[, "w"]
beta_hat_T <- mean(w_draws)
ssq_beta_hat_T <- sd(w_draws)
reject <- !(quantile(w_draws, 0.025) < 0 & quantile(w_draws, 0.975) > 0)
pval <- if (reject) 0 else 1
},
error = function(e) {
beta_hat_T <<- NA
ssq_beta_hat_T <<- NA
pval <<- NA
}
)
res <- rbind(res, data.frame(
n = n,
p = p,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "stan_glmer",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
########################### binaryMM ###########################
# beta_hat_T = NA; ssq_beta_hat_T = NA; pval = NA
# tryCatch({
#   # binaryMM requires a data frame and explicit column names
#   df_mm = data.frame(y = y, w = w, strat = strat)
#   df_mm = cbind(df_mm, X) # Add covariates
#
#   # Construct the formula dynamically based on X columns
#   if (is.null(colnames(X))) {
#     colnames(X) = paste0("V", 1:ncol(X))
#   }
#   x_names = colnames(X)
#   mm_formula = as.formula(paste("y ~ w +", paste(x_names, collapse = " + ")))
#
#   fit_mm = mm(
#     formula = mm_formula,
#     id = strat,
#     data = df_mm,
#     # 'average' provides the population-averaged (marginal) effects
#     # similar to GEE, but via a different estimation method
#     type = "marginal"
#   )
#
#   # Extracting coefficients for the treatment effect 'w'
#   # binaryMM stores results in a 'coefficients' matrix
#   mm_sum = summary(fit_mm)
#   beta_hat_T = mm_sum$coefficients["w", "Estimate"]
#   ssq_beta_hat_T = mm_sum$coefficients["w", "Std.Error"]
#
#   # Standard Wald-type p-value calculation
#   pval = 2 * pnorm(-abs(beta_hat_T / ssq_beta_hat_T))
#
# }, error = function(e) {
#   beta_hat_T <<- NA; ssq_beta_hat_T <<- NA; pval <<- NA
# })
#
# res = rbind(res, data.frame(
#   n = n,
#   p = p,
#   beta_T = beta_T,
#   X_style = X_style,
#   true_funtion = true_funtion,
#   regress_on_X = regress_on_X,
#   inference = "binaryMM",
#   beta_hat_T = beta_hat_T,
#   ssq_beta_hat_T = ssq_beta_hat_T,
#   pval = pval
# ))
} else { # if no x then remove the x parameter
discordant_viabele <- if (length(y_dis) > 5) {
TRUE
} else {
FALSE
}
########################### CLOGIT  ###########################
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
if (discordant_viabele) {
y_dis_0_1 <- ifelse(y_dis == -1, 0, 1)
model <- summary(glm(y_dis_0_1 ~ 0 + w_dis, family = "binomial"))$coefficients[1, c(1, 2)]
beta_hat_T <- model[1]
ssq_beta_hat_T <- model[2]
pval <- 2 * pnorm(min(c(-1, 1) * (beta_hat_T / ssq_beta_hat_T)))
}
res <- rbind(res, data.frame(
n = n,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "clogit",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
########################### LOGIT  ###########################
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
if (discordant_viabele) {
model <- summary(glm(y ~ w, family = "binomial"))$coefficients[2, c(1, 2)]
beta_hat_T <- model[1]
ssq_beta_hat_T <- model[2]
pval <- 2 * pnorm(min(c(-1, 1) * (beta_hat_T / ssq_beta_hat_T)))
}
res <- rbind(res, data.frame(
n = n,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "logit",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
########################### glmmTMB  ###########################
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
tryCatch(
{
fit_tmb <- glmmTMB(
y ~ w + (1 | strat),
family = binomial(),
data   = data.frame(y, X, w, strat)
)
model <- summary(fit_tmb)$coefficients$cond["w", c("Estimate", "Std. Error")]
beta_hat_T <- model[1]
ssq_beta_hat_T <- model[2]
pval <- 2 * pnorm(min(c(-1, 1) * (beta_hat_T / ssq_beta_hat_T)))
},
error = function(e) {
beta_hat_T <<- NA
ssq_beta_hat_T <<- NA
pval <<- NA
}
)
res <- rbind(res, data.frame(
n = n,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "glmmTMB",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
########################### GEE  ###########################
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
tryCatch(
{
fit_gee <- geeglm(
y ~ w,
id = strat,
family = binomial(link = "logit"),
corstr = "exchangeable",
data = data.frame(y, X, w, strat)
)
model <- summary(fit_gee)$coefficients["w", c("Estimate", "Std.err")]
beta_hat_T <- as.numeric(model[1])
ssq_beta_hat_T <- as.numeric(model[2])
pval <- 2 * pnorm(min(c(-1, 1) * (beta_hat_T / ssq_beta_hat_T)))
},
error = function(e) {
beta_hat_T <<- NA
ssq_beta_hat_T <<- NA
pval <<- NA
}
)
res <- rbind(res, data.frame(
n = n,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "GEE",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
}
rownames(res) <- NULL
return(res)
}
Run_sim <- function(p, beta_T, n, X_style) {
BIG_res <- data.frame()
y <- array(NA, n)
probs <- array(NA, n)
if (X_style == "correlated") { ############## correlated is the old style
Sigma <- 1 * (matrix(0.5, nrow = p, ncol = p) + diag(1 - 0.5, p))
X <- MASS::mvrnorm(n / 2, rep(0, p), Sigma)
X <- pnorm(X)
X <- matrix(2 * X - 1, ncol = p)
} else {
X <- matrix(runif((n / 2) * p, min = -1, max = 1), ncol = p)
X_plus_eps <- X + matrix(rnorm((n / 2) * p, 0, 0.05), ncol = p)
combined <- rbind(X, X_plus_eps)
ids <- order(c(1:(n / 2), 1:(n / 2)))
X <- combined[ids, ]
X[, 1] <- runif(n, min = -1, max = 1)
rm(X_plus_eps, combined, ids)
}
# df = data.frame(cbind(id = 1:n, X))
# df.dist = gendistance(data.frame(df[, -1]), idcol = 1)
# df.mdm = distancematrix(df.dist)
# df.match = nonbimatch(df.mdm)
#
# T_inx = df.match$halves[,2]
# C_ind = df.match$halves[,4]
# X = X[c(rbind(T_inx, C_ind)), ] #zip them together, so the mathces should be 1,1,2,2,3,3...
w <- c(rbind(replicate(n / 2, sample(c(0, 1)), simplify = TRUE)))
strat <- rep(1:(n / 2), each = 2)
for (true_funtion in true_funtions) {
if (true_funtion == "linear") {
beta_X_value <- if (p == 6) {
1.25
} else {
0.75
}
beta_X <- rep(beta_X_value, p)
beta_0 <- -0.5
probs <- 1 / (1 + exp(-(beta_0 + (as.matrix(X) %*% beta_X) + beta_T * w)))
} else {
f_x <- sin(pi * X[, 1] * X[, 2]) + X[, 3]^3 + X[, 4]^2 + X[, 5]^2
probs <- 1 / (1 + exp(-(f_x + beta_T * w)))
}
y <- rbinom(n, 1, probs)
# df = data.frame(y = y, probs = probs)
# ggplot(df, aes(x = probs, fill = factor(y))) +
#   geom_histogram(position = "identity", alpha = 0.6, bins = 30) +
#   labs(x = "Predicted probability", fill = "Outcome") +
#   scale_fill_manual(values = c("0" = "red", "1" = "blue")) +
#   theme_minimal()
for (regress_on_X in regress_on_Xs) {
if (regress_on_X == "one") {
X_run <- X[, 1, drop = FALSE]
} else if (regress_on_X == "some") {
if (p == 20) {
X_run <- X[, 1:5, drop = FALSE]
} else {
X_run <- X[, c(1, 2), drop = FALSE]
}
} else {
X_run <- X
}
one_res <- Do_Inference(y, X_run, w, strat, p, beta_T, n, X_style, true_funtion, regress_on_X)
BIG_res <- rbind(BIG_res, one_res)
}
}
return(BIG_res)
}
handlers(global = TRUE)
handlers("txtprogressbar")
registerDoFuture()
plan(multisession, workers = num_cores)
for (e_nsim in 1:external_nsim) {
with_progress({
prog <- progressor(along = 1:nrow(params))
results <- foreach(
row = iter(params, by = "row"),
.combine = rbind,
.packages = c(
"clogitR", "nbpMatching", "data.table",
"dplyr", "MASS", "Rcpp", "rstanarm"
)
) %dorng% {
# extract parameters
nsim <- row$nsim
p <- row$p
beta_T <- row$beta_T
n <- row$n
X_style <- row$X_style
res <- tryCatch(
{
out <- Run_sim(p, beta_T, n, X_style)
# cat("Successfully ran simulation")
prog()
out
},
error = function(e) {
cat(glue::glue("Error in nsim={nsim}: {e$message}"), "\n")
prog() # still update progress bar even if it fails
NULL # return NULL if failed, will be dropped in rbind
}
)
}
})
write.csv(results, file = paste0("C:/temp/clogitR_kap_test_from_scratch/", Nsim, "_", e_nsim, ".csv"), row.names = FALSE)
rm(results)
gc()
}
setwd("C:/Users/Jacob/clogitR_package_and_paper_repo/package_tests")
setwd("C:/Users/Jacob/clogitR_package_and_paper_repo")
devtools::load_all("bclogit")
setwd("C:/Users/Jacob/clogitR_package_and_paper_repo/package_tests")
setwd("C:/Users/Jacob/clogitR_package_and_paper_repo")
pacman::p_load(bclogit, dplyr, tidyr, data.table, doFuture, future, doRNG, foreach, progressr, doParallel, nbpMatching, doParallel, ggplot2, geepack, glmmTMB, rstan, binaryMM, rstanarm) # doParallel
