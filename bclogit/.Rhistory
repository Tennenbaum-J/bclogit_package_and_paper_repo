}
data_list <- list(
N = nrow(wX_dis),
K = ncol(wX_dis),
X = wX_dis,
y = y_dis_0_1,
mu = b_con, # example prior mean
Sigma = Sigma_con # example covariance (wide prior)
)
discordant_model <- tryCatch(
{
# for other aphas you would need to get the posterior for treatment effect and take the quarantines of that. you can get that from: post <- rstan::extract(fit); w_samples <- post$beta[, 1]
summary(rstan::sampling(sm, data = data_list, refresh = 0, chains = 1))$summary["beta[1]", c("mean", "sd", "2.5%", "97.5%")]
},
error = function(e) {
warning(sprintf("stan_glm failed: %s", e$message))
NULL
}
)
}
if (prior_type == "G prior") {
if (all(diag(Sigma_con) == 1e3)) {
ret <- list()
ret$betaT <- NA
ret$ssq_beta_T <- NA
ret$reject <- NA
ret$pval <- NA
return(ret) # model blew up
}
data_list <- list(
N = nrow(wX_dis),
K = ncol(wX_dis),
X = wX_dis,
y = y_dis_0_1,
mu = b_con,
Sigma = Sigma_con
)
discordant_model <- tryCatch(
{
# for other aphas you would need to get the posterior for treatment effect and take the quarantines of that. you can get that from: post <- rstan::extract(fit); w_samples <- post$beta[, 1]
mod = summary(rstan::sampling(sm_g, data = data_list, refresh = 0, chains = 1))$summary
g = mod["g", "mean"]
mod["beta[1]", c("mean", "sd", "2.5%", "97.5%")]
},
error = function(e) {
warning(sprintf("stan_glm failed: %s", e$message))
NULL
}
)
}
if (prior_type == "PMP") {
proj_matrix <- X_dis %*% solve(t(X_dis) %*% X_dis) %*% t(X_dis)
w_dis_ortho <- w_dis - proj_matrix %*% w_dis
# Prepare the data list for Stan (matching mvn_logistic_PMP.stan)
data_list <- list(
N = nrow(X_dis),
P = ncol(X_dis),
y = y_dis_0_1,
xw = as.vector(w_dis_ortho),
X = X_dis,
mu_A = as.array(b_con[-1]),
Sigma_A = as.matrix(Sigma_con[-1, -1, drop = FALSE])
)
discordant_model <- tryCatch(
{
# for other aphas you would need to get the posterior for treatment effect and take the quarantines of that. you can get that from: post <- rstan::extract(fit); w_samples <- post$beta[, 1]
summary(rstan::sampling(sm_PMP, data = data_list, refresh = 0, chains = 1))$summary["beta_w", c("mean", "sd", "2.5%", "97.5%")]
},
error = function(e) {
warning(sprintf("stan_glm failed: %s", e$message))
NULL
}
)
}
if (prior_type == "Hybrid") {
proj_matrix <- X_dis %*% solve(t(X_dis) %*% X_dis) %*% t(X_dis)
w_dis_ortho <- w_dis - proj_matrix %*% w_dis
# Prepare the data list for Stan
data_list <- list(
N = nrow(X_dis),
P = ncol(X_dis),
y = y_dis_0_1,
xw = as.vector(w_dis_ortho),
X = X_dis,
mu_A = as.array(b_con[-1]),
Sigma_A = as.matrix(Sigma_con[-1, -1, drop = FALSE])
)
# # 2. Build the data list to match the Stan model variables
# data_list = list(
#   N = nrow(wX_dis),
#   K = ncol(wX_dis),
#   X = wX_dis,
#   y = y_dis_0_1,
#   mu_T = 0,         # Center treatment prior at 0
#   V_T = 20,        # High variance for treatment (non-informative)
#   mu_X = mu_X_prior,
#   Sigma_X = Sigma_X_prior
# )
discordant_model <- tryCatch(
{
mod = summary(rstan::sampling(sm_hybrid, data = data_list, refresh = 0, chains = 1))$summary
g = mod["g", "mean"]
mod["beta_w", c("mean", "sd", "2.5%", "97.5%")]
#summary(rstan::sampling(sm_hybrid, data = data_list, refresh = 0, chains = 1))$summary["beta_w", c("mean", "sd", "2.5%", "97.5%")]
},
error = function(e) {
warning(sprintf("Hybrid PMP failed: %s", e$message))
NULL
}
)
}
ret <- list(
betaT = NA,
ssq_beta_T = NA,
reject = NA,
pval = NA,
g = NA
)
if (!is.null(discordant_model)) {
ret$betaT <- discordant_model[1]
ret$ssq_beta_T <- discordant_model[2]
ret$reject <- !(discordant_model[3] < 0 & discordant_model[4] > 0)
ret$pval <- if (ret$reject) 0 else 1
}
if (!is.null(g)) { ret$g = g }
return(ret)
}
Do_Inference <- function(y, X, w, strat, p, beta_T, n, true_funtion, regress_on_X) {
res <- data.frame(
n = numeric(),
p = numeric(),
beta_T = numeric(),
true_funtion = character(),
regress_on_X = character(),
inference = character(),
beta_hat_T = numeric(),
pval = numeric(),
g = numeric()
)
matched_data <-
bclogit:::process_matched_pairs_cpp(
strata = strat,
y = y,
X = data.matrix(X),
treatment = w
)
X_con <- matched_data$X_concordant
y_con <- matched_data$y_concordant
w_con <- matched_data$treatment_concordant
X_dis <- matched_data$X_diffs_discordant
y_dis <- matched_data$y_diffs_discordant
w_dis <- matched_data$treatment_diffs_discordant
dis_idx <- matched_data$discordant_idx + 1
discordant_viabele <- if (length(y_dis) > ncol(X) + 7) {
TRUE
} else {
FALSE
}
concordant_viabele <- if (length(y_con) > ncol(X) + 7) {
TRUE
} else {
FALSE
}
########################### CLOGIT  ###########################
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
if (discordant_viabele) {
y_dis_0_1 <- ifelse(y_dis == -1, 0, 1)
model <- summary(glm(y_dis_0_1 ~ 0 + w_dis + X_dis, family = "binomial"))$coefficients[1, c(1, 2)]
beta_hat_T <- model[1]
ssq_beta_hat_T <- model[2]
pval <- 2 * pnorm(min(c(-1, 1) * (beta_hat_T / ssq_beta_hat_T)))
}
res <- rbind(res, data.frame(
n = n,
p = p,
beta_T = beta_T,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "clogit",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval,
g = NA
))
########################### LOGIT  ###########################
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
if (TRUE) {
model <- summary(glm(y ~ w + X, family = "binomial"))$coefficients[2, c(1, 2)]
beta_hat_T <- model[1]
ssq_beta_hat_T <- model[2]
pval <- 2 * pnorm(min(c(-1, 1) * (beta_hat_T / ssq_beta_hat_T)))
}
res <- rbind(res, data.frame(
n = n,
p = p,
beta_T = beta_T,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "GLM",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval,
g = NA
))
########################### BAYESIAN ###########################
for (prior_type in c("normal", "G prior", "PMP", "Hybrid")) {
for (concordant_fit in c("GLM", "GEE", "GLMM")) {
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
g <- NA
if (discordant_viabele & concordant_viabele) {
model <- Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, prior_type, concordant_fit)
beta_hat_T <- model$betaT
ssq_beta_hat_T <- model$ssq_beta_T
pval <- model$pval
g = model$g
}
res <- rbind(res, data.frame(
n = n,
p = p,
beta_T = beta_T,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = paste0("bayesian_", prior_type, "_", concordant_fit),
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval,
g = g
))
}
}
########################### glmmTMB  ###########################
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
tryCatch(
{
fit_tmb <- glmmTMB(
y ~ X + w + (1 | strat),
family = binomial(),
data   = data.frame(y, X, w, strat)
)
model <- summary(fit_tmb)$coefficients$cond["w", c("Estimate", "Std. Error")]
beta_hat_T <- model[1]
ssq_beta_hat_T <- model[2]
pval <- 2 * pnorm(min(c(-1, 1) * (beta_hat_T / ssq_beta_hat_T)))
},
error = function(e) {
beta_hat_T <<- NA
ssq_beta_hat_T <<- NA
pval <<- NA
}
)
res <- rbind(res, data.frame(
n = n,
p = p,
beta_T = beta_T,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "GLMM",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval,
g = NA
))
########################### GEE  ###########################
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval <- NA
tryCatch(
{
fit_gee <- geeglm(
y ~ X + w,
id = strat,
family = binomial(link = "logit"),
corstr = "exchangeable",
data = data.frame(y, X, w, strat)
)
model <- summary(fit_gee)$coefficients["w", c("Estimate", "Std.err")]
beta_hat_T <- as.numeric(model[1])
ssq_beta_hat_T <- as.numeric(model[2])
pval <- 2 * pnorm(min(c(-1, 1) * (beta_hat_T / ssq_beta_hat_T)))
},
error = function(e) {
beta_hat_T <<- NA
ssq_beta_hat_T <<- NA
pval <<- NA
}
)
res <- rbind(res, data.frame(
n = n,
p = p,
beta_T = beta_T,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "GEE",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval,
g = NA
))
rownames(res) <- NULL
return(res)
}
Run_sim <- function(p, beta_T, n) {
BIG_res <- data.frame()
y <- array(NA, n)
probs <- array(NA, n)
X <- matrix(runif((n / 2) * p, min = -1, max = 1), ncol = p)
X_plus_eps <- X + matrix(rnorm((n / 2) * p, 0, 0.05), ncol = p)
combined <- rbind(X, X_plus_eps)
ids <- order(c(1:(n / 2), 1:(n / 2)))
X <- combined[ids, ]
X[, 1] <- runif(n, min = -1, max = 1)
rm(X_plus_eps, combined, ids)
w <- c(rbind(replicate(n / 2, sample(c(0, 1)), simplify = TRUE)))
strat <- rep(1:(n / 2), each = 2)
for (true_funtion in true_funtions) {
if (true_funtion == "linear") {
beta_X_value <- 1.25
beta_X <- rep(beta_X_value, p)
beta_0 <- -0.5
probs <- 1 / (1 + exp(-(beta_0 + (as.matrix(X) %*% beta_X) + beta_T * w)))
} else {
f_x <- sin(pi * X[, 1] * X[, 2]) + X[, 3]^3 + X[, 4]^2 + X[, 5]^2
probs <- 1 / (1 + exp(-(f_x + beta_T * w)))
}
y <- rbinom(n, 1, probs)
for (regress_on_X in regress_on_Xs) {
if (regress_on_X == "one") {
X_run <- X[, 1, drop = FALSE]
} else if (regress_on_X == "some") {
X_run <- X[, c(1, 2), drop = FALSE]
} else {
X_run <- X
}
one_res <- Do_Inference(y, X_run, w, strat, p, beta_T, n, true_funtion, regress_on_X)
BIG_res <- rbind(BIG_res, one_res)
}
}
return(BIG_res)
}
for (j in 1:120) {
cat("################", j, "################\n")
p = params[j,]$p
beta_T = params[j,]$beta_T
n = params[j,]$n
X_style = params[j,]$X_style
print(Run_sim(p = p, beta_T = beta_T, n = n, X_style = X_style)); cat('\n')
}
for (j in 1:120) {
cat("################", j, "################\n")
p = params[j,]$p
beta_T = params[j,]$beta_T
n = params[j,]$n
print(Run_sim(p = p, beta_T = beta_T, n = n)); cat('\n')
}
if (!require("bclogit", character.only = TRUE)) {
remotes::install_local("bclogit", dependencies = FALSE, force = TRUE, upgrade = "never")
library(bclogit)
}
pacman::p_load(dplyr, tidyr, data.table, doFuture, future, doRNG, foreach, progressr, doParallel, nbpMatching, doParallel, ggplot2, geepack, glmmTMB, rstan, binaryMM, rstanarm) # doParallel
for (j in 1:120) {
cat("################", j, "################\n")
p = params[j,]$p
beta_T = params[j,]$beta_T
n = params[j,]$n
print(Run_sim(p = p, beta_T = beta_T, n = n)); cat('\n')
}
options(error = recover)
options(error = recover)
if (!require("pacman")) install.packages("pacman")
pacman::p_load(dplyr, tidyr, data.table, MASS, bclogit)
# --- Parameters (Default values from parallel test script) ---
n <- 500 # Total sample size (number of individuals)
p <- 6 # Number of covariates
beta_T <- 0.5 # Treatment effect size
X_style <- "non-correlated" # Options: "correlated", "non-correlated"
true_function <- "linear" # Options: "linear", "non-linear"
regress_on_X <- "some" # Options: "all", "one", "some", "none"
# 1. Generate X matrix
if (X_style == "correlated") {
Sigma <- 1 * (matrix(0.5, nrow = p, ncol = p) + diag(1 - 0.5, p))
X_raw <- MASS::mvrnorm(n / 2, rep(0, p), Sigma)
X_raw <- pnorm(X_raw)
X_raw <- matrix(2 * X_raw - 1, ncol = p)
} else {
# non-correlated
X_raw <- matrix(runif((n / 2) * p, min = -1, max = 1), ncol = p)
X_plus_eps <- X_raw + matrix(rnorm((n / 2) * p, 0, 0.05), ncol = p)
combined <- rbind(X_raw, X_plus_eps)
# Shuffle pairs to mix them up but keep pairs together logically?
# Wait, the original code orders by c(1:(n/2), 1:(n/2)) which interleaves them effectively if we consider strat logic later.
# Let's match original exactly:
ids <- order(c(1:(n / 2), 1:(n / 2)))
X_raw <- combined[ids, ]
# Special modification for column 1
X_raw[, 1] <- runif(n, min = -1, max = 1)
}
# 2. Generate w (treatment) and strat (strata)
# w is randomized within pairs (0,1) or (1,0)
w <- c(rbind(replicate(n / 2, sample(c(0, 1)), simplify = TRUE)))
strat <- rep(1:(n / 2), each = 2)
# 3. Calculate Probabilities and Outcome (y)
if (true_function == "linear") {
beta_X_value <- if (p == 6) {
1.25
} else {
0.75
}
beta_X <- rep(beta_X_value, p)
beta_0 <- -0.5
probs <- 1 / (1 + exp(-(beta_0 + (as.matrix(X_raw) %*% beta_X) + beta_T * w)))
} else {
# non-linear
f_x <- sin(pi * X_raw[, 1] * X_raw[, 2]) + X_raw[, 3]^3 + X_raw[, 4]^2 + X_raw[, 5]^2
probs <- 1 / (1 + exp(-(f_x + beta_T * w)))
}
y <- rbinom(n, 1, probs)
# 4. Select Covariates for Regression (X)
if (regress_on_X == "one") {
X <- X_raw[, 1, drop = FALSE]
} else if (regress_on_X == "some") {
if (p == 20) {
X <- X_raw[, 1:5, drop = FALSE]
} else {
X <- X_raw[, c(1, 2), drop = FALSE]
}
} else if (regress_on_X == "all") {
X <- X_raw
} else {
# none
X <- NULL
}
fit <- bclogit(y ~ X, treatment = w, strat = strat)
if (!require("pacman")) install.packages("pacman")
setwd("C:/Users/Jacob/clogitR_package_and_paper_repo/package_tests")
setwd("C:/Users/Jacob/clogitR_package_and_paper_repo/bclogit")
devtools::load_all()
# --- Parameters (Default values from parallel test script) ---
n <- 500 # Total sample size (number of individuals)
p <- 6 # Number of covariates
beta_T <- 0.5 # Treatment effect size
X_style <- "non-correlated" # Options: "correlated", "non-correlated"
true_function <- "linear" # Options: "linear", "non-linear"
regress_on_X <- "some" # Options: "all", "one", "some", "none"
# 1. Generate X matrix
if (X_style == "correlated") {
Sigma <- 1 * (matrix(0.5, nrow = p, ncol = p) + diag(1 - 0.5, p))
X_raw <- MASS::mvrnorm(n / 2, rep(0, p), Sigma)
X_raw <- pnorm(X_raw)
X_raw <- matrix(2 * X_raw - 1, ncol = p)
} else {
# non-correlated
X_raw <- matrix(runif((n / 2) * p, min = -1, max = 1), ncol = p)
X_plus_eps <- X_raw + matrix(rnorm((n / 2) * p, 0, 0.05), ncol = p)
combined <- rbind(X_raw, X_plus_eps)
# Shuffle pairs to mix them up but keep pairs together logically?
# Wait, the original code orders by c(1:(n/2), 1:(n/2)) which interleaves them effectively if we consider strat logic later.
# Let's match original exactly:
ids <- order(c(1:(n / 2), 1:(n / 2)))
X_raw <- combined[ids, ]
# Special modification for column 1
X_raw[, 1] <- runif(n, min = -1, max = 1)
}
# 2. Generate w (treatment) and strat (strata)
# w is randomized within pairs (0,1) or (1,0)
w <- c(rbind(replicate(n / 2, sample(c(0, 1)), simplify = TRUE)))
strat <- rep(1:(n / 2), each = 2)
# 3. Calculate Probabilities and Outcome (y)
if (true_function == "linear") {
beta_X_value <- if (p == 6) {
1.25
} else {
0.75
}
beta_X <- rep(beta_X_value, p)
beta_0 <- -0.5
probs <- 1 / (1 + exp(-(beta_0 + (as.matrix(X_raw) %*% beta_X) + beta_T * w)))
} else {
# non-linear
f_x <- sin(pi * X_raw[, 1] * X_raw[, 2]) + X_raw[, 3]^3 + X_raw[, 4]^2 + X_raw[, 5]^2
probs <- 1 / (1 + exp(-(f_x + beta_T * w)))
}
y <- rbinom(n, 1, probs)
# 4. Select Covariates for Regression (X)
if (regress_on_X == "one") {
X <- X_raw[, 1, drop = FALSE]
} else if (regress_on_X == "some") {
if (p == 20) {
X <- X_raw[, 1:5, drop = FALSE]
} else {
X <- X_raw[, c(1, 2), drop = FALSE]
}
} else if (regress_on_X == "all") {
X <- X_raw
} else {
# none
X <- NULL
}
fit <- bclogit(y ~ X, treatment = w, strat = strat)
confint(fit)
confint(fit, type = "HPD_one")
confint(fit, type = "HPD_many")
