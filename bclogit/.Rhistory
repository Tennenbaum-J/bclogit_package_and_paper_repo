matched_data <- bclogit:::process_matched_pairs_cpp(
strata = strat,
y = y,
X = data.matrix(X),
treatment = w
)
X_con <- matched_data$X_concordant
y_con <- matched_data$y_concordant
X_dis <- matched_data$X_diffs_discordant
y_dis <- matched_data$y_diffs_discordant
discordant_viable <- if (length(y_dis) > ncol(X) + 7) TRUE else FALSE
concordant_viable <- if (length(y_con) > ncol(X) + 7) TRUE else FALSE
########################### BAYESIAN ###########################
for (prior_type in c("Naive", "G prior", "PMP", "Hybrid")) {
for (concordant_fit in c("GLM", "GEE", "GLMM")) {
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval_hdr <- NA
pval_cr <- NA
g <- NA
if (discordant_viable & concordant_viable) {
fit <- tryCatch(
{
bclogit::bclogit(
y = y,
X = data.frame(X),
treatment = w,
strata = strat,
concordant_method = concordant_fit,
prior_type = prior_type,
chains = 1,
stan_refresh = 0
)
},
error = function(e) {
warning(sprintf("bclogit failed: %s", e$message))
NULL
}
)
if (!is.null(fit) && !is.null(fit$model)) {
beta_hat_T <- fit$coefficients[1]
ssq_beta_hat_T <- fit$var[1, 1]
# Compute P-value based on 95% HDR (Disjoint / Multimodal)
hpd_res <- confint(fit, parm = 1, type = "HPD_many", level = 0.95)
if (!is.null(hpd_res)) {
zero_in_hdi <- any(hpd_res[, "lower"] < 0 & hpd_res[, "upper"] > 0)
reject <- !zero_in_hdi
pval_hdr <- if (reject) 0 else 1
}
# Compute P-value based on 95% Credible Interval
mod_summ <- rstan::summary(fit$model)$summary
target_param <- ifelse(prior_type %in% c("Naive", "G prior"), "beta[1]", "beta_w")
if (target_param %in% rownames(mod_summ)) {
ci_lower <- mod_summ[target_param, "2.5%"]
ci_upper <- mod_summ[target_param, "97.5%"]
reject <- !(ci_lower < 0 & ci_upper > 0)
pval_cr <- if (reject) 0 else 1
}
if (prior_type %in% c("G prior", "Hybrid") && "g" %in% rownames(mod_summ)) {
g <- mod_summ["g", "mean"]
}
}
}
res <- rbind(res, data.frame(
n = n, p = p, beta_T = beta_T, true_function = true_function,
regress_on_X = regress_on_X,
inference = paste0("bayesian_", prior_type, "_", concordant_fit, "_HDR"),
beta_hat_T = beta_hat_T, ssq_beta_hat_T = ssq_beta_hat_T, pval = pval_hdr, g = g
))
res <- rbind(res, data.frame(
n = n, p = p, beta_T = beta_T, true_function = true_function,
regress_on_X = regress_on_X,
inference = paste0("bayesian_", prior_type, "_", concordant_fit, "_CR"),
beta_hat_T = beta_hat_T, ssq_beta_hat_T = ssq_beta_hat_T, pval = pval_cr, g = g
))
}
}
rownames(res) <- NULL
return(res)
}
# simulate the data
Run_sim <- function(p, beta_T, n) {
BIG_res <- data.frame()
y <- array(NA, n)
probs <- array(NA, n)
X <- matrix(runif((n / 2) * p, min = -1, max = 1), ncol = p)
X_plus_eps <- X + matrix(rnorm((n / 2) * p, 0, 0.05), ncol = p)
combined <- rbind(X, X_plus_eps)
ids <- order(c(1:(n / 2), 1:(n / 2)))
X <- combined[ids, ]
X[, 1] <- runif(n, min = -1, max = 1)
rm(X_plus_eps, combined, ids)
w <- c(rbind(replicate(n / 2, sample(c(0, 1)), simplify = TRUE)))
strat <- rep(1:(n / 2), each = 2)
for (true_function in true_functions) {
if (true_function == "linear") {
beta_X_value <- 1.25
beta_X <- rep(beta_X_value, p)
beta_0 <- -0.5
probs <- 1 / (1 + exp(-(beta_0 + (as.matrix(X) %*% beta_X) + beta_T * w)))
} else {
f_x <- sin(pi * X[, 1] * X[, 2]) + X[, 3]^3 + X[, 4]^2 + X[, 5]^2
probs <- 1 / (1 + exp(-(f_x + beta_T * w)))
}
y <- rbinom(n, 1, probs)
for (regress_on_X in regress_on_Xs) {
if (regress_on_X == "one") {
X_run <- X[, 1, drop = FALSE]
} else if (regress_on_X == "two") {
X_run <- X[, c(1, 2), drop = FALSE]
} else {
X_run <- X
}
one_res <- Do_Inference(y, X_run, w, strat, p, beta_T, n, true_function, regress_on_X)
BIG_res <- rbind(BIG_res, one_res)
}
}
return(BIG_res)
}
for (j in 1:120) {
cat("################", j, "################\n")
p = params[j,]$p
beta_T = params[j,]$beta_T
n = params[j,]$n
X_style = params[j,]$X_style
print(Run_sim(p = p, beta_T = beta_T, n = n, X_style = X_style)); cat('\n')
}
for (j in 1:120) {
cat("################", j, "################\n")
p = params[j,]$p
beta_T = params[j,]$beta_T
n = params[j,]$n
X_style = params[j,]$X_style
print(Run_sim(p = p, beta_T = beta_T, n = n)); cat('\n')
}
n= 500
beta_T = 0.5
BIG_res <- data.frame()
y <- array(NA, n)
probs <- array(NA, n)
X <- matrix(runif((n / 2) * p, min = -1, max = 1), ncol = p)
X_plus_eps <- X + matrix(rnorm((n / 2) * p, 0, 0.05), ncol = p)
combined <- rbind(X, X_plus_eps)
ids <- order(c(1:(n / 2), 1:(n / 2)))
X <- combined[ids, ]
X[, 1] <- runif(n, min = -1, max = 1)
rm(X_plus_eps, combined, ids)
w <- c(rbind(replicate(n / 2, sample(c(0, 1)), simplify = TRUE)))
strat <- rep(1:(n / 2), each = 2)
beta_X_value <- 1.25
beta_X <- rep(beta_X_value, p)
beta_0 <- -0.5
probs <- 1 / (1 + exp(-(beta_0 + (as.matrix(X) %*% beta_X) + beta_T * w)))
if (true_function == "linear") {
beta_X_value <- 1.25
beta_X <- rep(beta_X_value, p)
beta_0 <- -0.5
probs <- 1 / (1 + exp(-(beta_0 + (as.matrix(X) %*% beta_X) + beta_T * w)))
} else {
f_x <- sin(pi * X[, 1] * X[, 2]) + X[, 3]^3 + X[, 4]^2 + X[, 5]^2
probs <- 1 / (1 + exp(-(f_x + beta_T * w)))
}
y <- rbinom(n, 1, probs)
# result data.frame
res <- data.frame(
n = numeric(),
p = numeric(),
beta_T = numeric(),
true_function = character(),
regress_on_X = character(),
inference = character(),
beta_hat_T = numeric(),
pval = numeric(),
g = numeric()
)
# Check viable conditions
matched_data <- bclogit:::process_matched_pairs_cpp(
strata = strat,
y = y,
X = data.matrix(X),
treatment = w
)
X_con <- matched_data$X_concordant
y_con <- matched_data$y_concordant
X_dis <- matched_data$X_diffs_discordant
y_dis <- matched_data$y_diffs_discordant
y_dis
discordant_viable <- if (length(y_dis) > ncol(X) + 7) TRUE else FALSE
concordant_viable <- if (length(y_con) > ncol(X) + 7) TRUE else FALSE
concordant_viable
fit <- tryCatch(
{
bclogit::bclogit(
y = y,
X = data.frame(X),
treatment = w,
strata = strat,
concordant_method = concordant_fit,
prior_type = prior_type,
chains = 1,
stan_refresh = 0
)
},
error = function(e) {
warning(sprintf("bclogit failed: %s", e$message))
NULL
}
)
prior_type
X
concordant_fit
concordant_fit ' "GLM'
concordant_fit = "GLM'
prior_type = "Naive"
prior_type = "Naive"
concordant_fit = "GLM'
fit <- tryCatch(
{
bclogit::bclogit(
y = y,
X = data.frame(X),
treatment = w,
strata = strat,
concordant_method = concordant_fit,
prior_type = prior_type,
chains = 1,
stan_refresh = 0
)
},
error = function(e) {
warning(sprintf("bclogit failed: %s", e$message))
fit <- tryCatch(
{
bclogit::bclogit(
y = y,
X = data.frame(X),
treatment = w,
strata = strat,
concordant_method = concordant_fit,
prior_type = prior_type,
chains = 1,
stan_refresh = 0
)
},
error = function(e) {
warning(sprintf("bclogit failed: %s", e$message))
NULL
}
)
bclogit::bclogit(
y = y,
X = data.frame(X),
treatment = w,
strata = strat,
concordant_method = concordant_fit,
prior_type = prior_type,
chains = 1,
stan_refresh = 0
)
options(error = recover)
bclogit::bclogit(
y = y,
X = data.frame(X),
treatment = w,
strata = strat,
concordant_method = concordant_fit,
prior_type = prior_type,
chains = 1,
stan_refresh = 0
)
bclogit::bclogit(
y~X,
data = data.frame(y = y, X = X),
treatment = w,
strata = strat,
concordant_method = concordant_fit,
prior_type = prior_type,
chains = 1,
stan_refresh = 0
)
X
t_name
response
X
trt_vec
strata_vec
t_name
bclogit::bclogit(
y~X,
data = data.frame(y = y, X = X),
treatment = w,
strata = strat,
concordant_method = concordant_fit,
prior_type = prior_type,
chains = 1,
stan_refresh = 0
)
bclogit::bclogit(
y~X,
data = data.frame(y = y, X = X),
treatment = w,
strata = strat,
concordant_method = concordant_fit,
prior_type = prior_type
)
concordant_method
concordant_method
concordant_method = "GLM"
prior_type
bclogit::bclogit(
y~X,
data = data.frame(y = y, X = X),
treatment = w,
strata = strat,
concordant_method = concordant_fit,
prior_type = prior_type
)
concordant_method
bclogit::bclogit(
y~X,
data = data.frame(y = y, X = X),
treatment = w,
strata = strat,
#concordant_method = concordant_fit,
prior_type = prior_type
)
concordant_method
concordant_fit
concordant_fit = "GLM"
bclogit::bclogit(
y~X,
data = data.frame(y = y, X = X),
treatment = w,
strata = strat,
concordant_method = concordant_fit,
prior_type = prior_type
)
bclogit::bclogit(
y~X,
data = data.frame(y = y, X = X),
treatment = w,
strata = strat,
concordant_method = concordant_fit,
prior_type = prior_type,
chains = 1,
stan_refresh = 0
)
bclogit::bclogit(
y~X,
data = data.frame(y = y, X = X),
treatment = w,
strata = strat,
concordant_method = concordant_fit,
prior_type = prior_type,
#chains = 1,
stan_refresh = 0
)
fit <- tryCatch(
{
bclogit::bclogit(
y~X,
data = data.frame(y = y, X = X),
treatment = w,
strata = strat,
concordant_method = concordant_fit,
prior_type = prior_type
)
},
error = function(e) {
warning(sprintf("bclogit failed: %s", e$message))
NULL
}
)
fit
summary(fit)
########################### BAYESIAN ###########################
for (prior_type in c("Naive", "G prior", "PMP", "Hybrid")) {
for (concordant_fit in c("GLM", "GEE", "GLMM")) {
beta_hat_T <- NA
ssq_beta_hat_T <- NA
pval_hdr <- NA
pval_cr <- NA
g <- NA
if (discordant_viable & concordant_viable) {
fit <- tryCatch(
{
bclogit::bclogit(
y~X,
data = data.frame(y = y, X = X),
treatment = w,
strata = strat,
concordant_method = concordant_fit,
prior_type = prior_type
)
},
error = function(e) {
warning(sprintf("bclogit failed: %s", e$message))
NULL
}
)
if (!is.null(fit) && !is.null(fit$model)) {
beta_hat_T <- fit$coefficients[1]
ssq_beta_hat_T <- fit$var[1, 1]
# Compute P-value based on 95% HDR (Disjoint / Multimodal)
hpd_res <- confint(fit, parm = 1, type = "HPD_many", level = 0.95)
if (!is.null(hpd_res)) {
zero_in_hdi <- any(hpd_res[, "lower"] < 0 & hpd_res[, "upper"] > 0)
reject <- !zero_in_hdi
pval_hdr <- if (reject) 0 else 1
}
# Compute P-value based on 95% Credible Interval
mod_summ <- rstan::summary(fit$model)$summary
target_param <- ifelse(prior_type %in% c("Naive", "G prior"), "beta[1]", "beta_w")
if (target_param %in% rownames(mod_summ)) {
ci_lower <- mod_summ[target_param, "2.5%"]
ci_upper <- mod_summ[target_param, "97.5%"]
reject <- !(ci_lower < 0 & ci_upper > 0)
pval_cr <- if (reject) 0 else 1
}
if (prior_type %in% c("G prior", "Hybrid") && "g" %in% rownames(mod_summ)) {
g <- mod_summ["g", "mean"]
}
}
}
res <- rbind(res, data.frame(
n = n, p = p, beta_T = beta_T, true_function = true_function,
regress_on_X = regress_on_X,
inference = paste0("bayesian_", prior_type, "_", concordant_fit, "_HDR"),
beta_hat_T = beta_hat_T, ssq_beta_hat_T = ssq_beta_hat_T, pval = pval_hdr, g = g
))
res <- rbind(res, data.frame(
n = n, p = p, beta_T = beta_T, true_function = true_function,
regress_on_X = regress_on_X,
inference = paste0("bayesian_", prior_type, "_", concordant_fit, "_CR"),
beta_hat_T = beta_hat_T, ssq_beta_hat_T = ssq_beta_hat_T, pval = pval_cr, g = g
))
}
}
fit
concordant_fit = "GEE"
prior_type
fit <- tryCatch(
{
bclogit::bclogit(
y~X,
data = data.frame(y = y, X = X),
treatment = w,
strata = strat,
concordant_method = concordant_fit,
prior_type = prior_type
)
},
error = function(e) {
warning(sprintf("bclogit failed: %s", e$message))
NULL
}
)
summary(fit)
fit <- tryCatch(
{
bclogit::bclogit(
y ~ X,
data = data.frame(y = y, X = X),
treatment = w,
strata = strat,
concordant_method = concordant_fit,
prior_type = prior_type
)
},
error = function(e) {
warning(sprintf("bclogit failed: %s", e$message))
NULL
}
)
bclogit::bclogit(
y ~ X,
data = data.frame(y = y, X = X),
treatment = w,
strata = strat,
concordant_method = concordant_fit,
prior_type = prior_type
)
length(y_dis)
length(y_con)
prior_type = "PMP"
concordant_fit
bclogit::bclogit(
y ~ X,
data = data.frame(y = y, X = X),
treatment = w,
strata = strat,
concordant_method = concordant_fit,
prior_type = prior_type
)
summary(fit)
if (!require("bclogit", character.only = TRUE)) {
remotes::install_local("bclogit", dependencies = FALSE, force = TRUE, upgrade = "never")
library(bclogit)
}
bclogit::bclogit(
y ~ X,
data = data.frame(y = y, X = X),
treatment = w,
strata = strat,
concordant_method = concordant_fit,
prior_type = prior_type
)
setwd("C:/Users/Jacob/bclogit_package_and_paper_repo/package_tests")
devtools::load_all()
setwd("C:/Users/Jacob/bclogit_package_and_paper_repo/bclogit")
devtools::load_all()
devtools::load_all()
